var documenterSearchIndex = {"docs":
[{"location":"comparison/#Comparison-of-Julia's-Symbolics.jl-vs-SymPy-for-Symbolic-Computation-1","page":"Comparison Against SymPy","title":"Comparison of Julia's Symbolics.jl vs SymPy for Symbolic Computation","text":"","category":"section"},{"location":"comparison/#","page":"Comparison Against SymPy","title":"Comparison Against SymPy","text":"Symbolics.jl is a symbolic modeling language for Julia built in Julia. Its goal is very different from Sympy: it was made to support symbolic-numerics, the combination of symbolic computing with numerical methods to allow for extreme performance computing that would not be possible without modifying the model. Because of this, Symbolics.jl excels in many areas due to purposeful design decisions:","category":"page"},{"location":"comparison/#","page":"Comparison Against SymPy","title":"Comparison Against SymPy","text":"Performance: Symbolics.jl is built in Julia, whereas SymPy was built in Python. Thus the performance bar for Symbolics.jl is much higher. Symbolics.jl started because SymPy was far too slow and SymEngine was far too inflexible for the projects they were doing. Performance is key to Symbolics.jl. If you find any performance issues, please file an issue.\nbuild_function: lambdify is \"fine\" for some people, but if you're building a super fast MPI-enabled Julia/C/Fortran simulation code, having a function that hits the Python interpreter is less than optimal. By default, build_function builds fast JIT-compiled functions due to being in Julia. However, it has support for things like static arrays, non-allocating functions via mutation, fast functions on sparse matrices and arrays of arrays, etc.: all core details of doing high performance computing.\nParallelism: Symbolics.jl has pervasive parallelism. The symbolic simplification via SymbolicUtils.jl has built-in parallelism, Symbolics.jl builds functions that parallelizes across threads. Symbolics.jl is compatible with GPU libraries like CUDA.jl.\nPrimitives for high-performance numerics. Features like ODESystem can be used to easily generate automatically parallelized ODE solver code with sparse Jacobians and all of the pieces required to get the most optimal solves. Support for differential-algebraic equations, chemical reaction networks, and generation of code for nonlinear optimization tools makes Symbolics.jl a tool for, well, building, generating, and analyzing models.\nDeep integration with the Julia ecosystem: Symbolics.jl's integration with neural networks is not the only thing that's deep. Symbolics.jl is built with the same philosophy as other SciML packages, eschewing \"monorepos\" for a distributed development approach that ties together the work of many developers. The differentiation parts utilize tools from automatic differentiation libraries, all linear algebra functionality comes from tracing Julia Base itself, symbolic rewriting (simplification and substitution) comes from SymbolicUtils.jl, parallelism comes from Julia Base libraries and Dagger.jl, and etc. SciML Tools like DataDrivenDiffEq.jl can reconstruct symbolic expressions from neural networks and data while NeuralPDE.jl can automatically solve partial differential equations from symbolic descriptions using physics-informed neural networks. The list keeps going. All told, by design Symbolics.jl's development moves fast because it's effectively using the work of hundreds of Julia developers, allowing it to grow fast.","category":"page"},{"location":"manual/variables/#Variable-and-Equation-Types-1","page":"Variable and Equation Types","title":"Variable and Equation Types","text":"","category":"section"},{"location":"manual/variables/#","page":"Variable and Equation Types","title":"Variable and Equation Types","text":"Symbolics IR mirrors the Julia AST but allows for easy mathematical manipulation by itself following mathematical semantics. The base of the IR is the Sym type, which defines a symbolic variable. Registered (mathematical) functions on Syms (or istree objects) return an expression that istree. For example, op1 = x+y is one symbolic object and op2 = 2z is another, and so op1*op2 is another tree object. Then, at the top, an Equation, normally written as op1 ~ op2, defines the symbolic equality between two operations.","category":"page"},{"location":"manual/variables/#Types-1","page":"Variable and Equation Types","title":"Types","text":"","category":"section"},{"location":"manual/variables/#","page":"Variable and Equation Types","title":"Variable and Equation Types","text":"Sym, Term, and FnType are from SymbolicUtils.jl. Note that in Symbolics, we always use Sym{Real}, Term{Real}, and FnType{Tuple{Any}, Real}. To get the arguments of a istree object use arguments(t::Term), and to get the operation, use operation(t::Term). However, note that one should never dispatch on Term or test isa Term. Instead, one needs to use SymbolicUtils.istree to check if arguments and operation is defined.","category":"page"},{"location":"manual/variables/#","page":"Variable and Equation Types","title":"Variable and Equation Types","text":"Equation\n@variables\nBase.:~(::Num, ::Num)","category":"page"},{"location":"manual/variables/#Symbolics.Equation","page":"Variable and Equation Types","title":"Symbolics.Equation","text":"struct Equation\n\nAn equality relationship between two expressions.\n\nFields\n\nlhs\nThe expression on the left-hand side of the equation.\nrhs\nThe expression on the right-hand side of the equation.\n\n\n\n\n\n","category":"type"},{"location":"manual/variables/#Symbolics.@variables","page":"Variable and Equation Types","title":"Symbolics.@variables","text":"Define one or more unknown variables.\n\n@parameters t α σ(..) β[1:2]\n@variables w(..) x(t) y() z(t, α, x)\n\nexpr = β₁* x + y^α + σ(3) * (z - t) - β₂ * w(t - 1)\n\nNote that @parameters and @variables implicitly add () to values that are not given a call. The former specifies the values as known, while the latter specifies it as unknown. (..) signifies that the value should be left uncalled.\n\nSometimes it is convenient to define arrays of variables to model things like x₁,…,x₃. The @variables and @parameters macros support this with the following syntax:\n\n@variables x[1:3];\nx\n\n3-element Array{Operation,1}:\n x₁()\n x₂()\n x₃()\n\n# support for arbitrary ranges and tensors\n@variables y[2:3,1:5:6];\ny\n\n2×2 Array{Operation,2}:\n    y₂̒₁() y₂̒₆()\n    y₃̒₁() y₃̒₆()\n\n# also works for dependent variables\n@parameters t; @variables z[1:3](t);\nz\n\n3-element Array{Operation,1}:\n z₁(t())\n z₂(t())\n z₃(t())\n\n\n\n\n\n","category":"macro"},{"location":"manual/variables/#Base.:~-Tuple{Num,Num}","page":"Variable and Equation Types","title":"Base.:~","text":"~(lhs::Num, rhs::Num) -> Equation\n\n\nCreate an Equation out of two Num instances, or an Num and a Number.\n\nExamples\n\njulia> using ModelingToolkit\n\njulia> @variables x y;\n\njulia> x ~ y\nEquation(x(), y())\n\njulia> x - y ~ 0\nEquation(x() - y(), 0)\n\n\n\n\n\n","category":"method"},{"location":"manual/variables/#A-note-about-functions-restricted-to-Numbers-1","page":"Variable and Equation Types","title":"A note about functions restricted to Numbers","text":"","category":"section"},{"location":"manual/variables/#","page":"Variable and Equation Types","title":"Variable and Equation Types","text":"Sym and Term objects are NOT subtypes of Number. Symbolics provides a simple wrapper type called Num which is a subtype of Real. Num wraps either a Sym or a Term or any other object, defines the same set of operations as symbolic expressions and forwards those to the values it wraps. You can use Symbolics.value function to unwrap a Num.","category":"page"},{"location":"manual/variables/#","page":"Variable and Equation Types","title":"Variable and Equation Types","text":"By default, the @variables macros return Num-wrapped objects so as to allow calling functions which are restricted to Number or Real.","category":"page"},{"location":"manual/variables/#","page":"Variable and Equation Types","title":"Variable and Equation Types","text":"julia> @variables t x y z(t);\n\njulia> Symbolics.operation(Symbolics.value(x + y))\n+ (generic function with 377 methods)\n\njulia> Symbolics.operation(Symbolics.value(z))\nz(::Any)::Real\n\njulia> Symbolics.arguments(Symbolics.value(x + y))\n2-element Vector{Sym{Real}}:\n x\n y","category":"page"},{"location":"tutorials/symbolic_functions/#Symbolic-Calculations-and-Building-Fast-Parallel-Functions-1","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"","category":"section"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Symbolics.jl is a symbolic modeling language. The way to define symbolic variables is via the @variables macro:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"@variables x y","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"After defining variables as symbolic, symbolic expressions, which we call a istree object, can be generated by utilizing Julia expressions. For example:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"z = x^2 + y","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Here, z is an expression tree for \"square x and add y\". To make an array of symbolic expressions, simply make an array of symbolic expressions:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"A = [x^2+y 0 2x\n     0     0 2y\n     y^2+x 0 0]\n\n3×3 Array{Num,2}:\n  x ^ 2 + y  0  2x\n  0  0  2y\n  y ^ 2 + x  0  0","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Note that by default, @variables returns Sym or istree objects wrapped in Num in order to make them behave like subtypes of Real. Any operation on these Num objects will return a new Num object, wrapping the result of computing symbolically on the underlying values.","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"To better view the results, we can use Latexify.jl. Symbolics.jl comes with Latexify recipes so it works automatically:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"using Latexify\nlatexify(A)","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"beginequation\nleft\nbeginarrayccc\n(x ^ 2) + y  0  2 * x \n0  0  2 * y \n(y ^ 2) + x  0  0 \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Normal Julia functions work on Symbolics expressions, so if we want to create the sparse version of A we would just call sparse:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"using SparseArrays\nspA = sparse(A)\n\n3×3 SparseMatrixCSC{Num,Int64} with 4 stored entries:\n  [1, 1]  =  (x ^ 2) + y\n  [3, 1]  =  (y ^ 2) + x\n  [1, 3]  =  2 * x\n  [2, 3]  =  2 * y","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"We can thus use normal Julia functions as generators for sparse expressions. For example, here we will define","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"function f(u)\n  [u[1]-u[3],u[1]^2-u[2],u[3]+u[2]]\nend\nf([x,y,z]) # Recall that z = x^2 + y\n\n3-element Array{Num,1}:\n x - (x ^ 2 + y)\n       x ^ 2 - y\n (x ^ 2 + y) + y","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Or we can build array variables and use these to trace:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"@variables u[1:3]\nf(u)\n\n3-element Array{Num,1}:\n     u₁ - u₃\n u₁ ^ 2 - u₂\n     u₃ + u₂","category":"page"},{"location":"tutorials/symbolic_functions/#Building-Functions-1","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Building Functions","text":"","category":"section"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"The function for building functions is the aptly-named build_function. The first argument is the symbolic expression or the array of symbolic expressions to compile, and the trailing arguments are the arguments for the function. For example:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"to_compute = [x^2 + y, y^2 + x]\nf_expr = build_function(to_compute,[x,y])","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"gives back two codes. The first is a function f([x,y]) that computes and builds an output vector [x^2 + y, y^2 + x]. Because this tool was made to be used by all the cool kids writing fast Julia codes, it is specialized to Julia and supports features like StaticArrays. For example:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"myf = eval(f_expr[1])\nmyf(SA[2.0,3.0])\n\n2-element SArray{Tuple{2},Float64,1,2} with indices SOneTo(2):\n  7.0\n 11.0","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"The second function is an in-place non-allocating mutating function which mutates its first value:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"f_expr[2]\n\n:((var\"##MTIIPVar#292\", var\"##MTKArg#290\")->begin\n          @inbounds begin\n                  let (x, y) = (var\"##MTKArg#290\"[1], var\"##MTKArg#290\"[2])\n                      var\"##MTIIPVar#292\"[1] = (getproperty(Base, :+))(x ^ 2, y)\n                      var\"##MTIIPVar#292\"[2] = (getproperty(Base, :+))(y ^ 2, x)\n                  end\n              end\n          nothing\n      end)","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Thus we'd use it like the following:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"myf! = eval(f_expr[2])\nout = zeros(2)\nmyf!(out,[2.0,3.0])\nout\n\n2-element Array{Float64,1}:\n  7.0\n 11.0","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"To save the symbolic calculations for later, we can take this expression and save it out to a file:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"write(\"function.jl\", string(f_expr[2]))","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Note that if we need to avoid eval, for example to avoid world-age issues, one could do expression = Val{false}:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"build_function(to_compute,[x,y],expression=Val{false})","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"which will use RuntimeGeneratedFunctions.jl to build Julia functions which avoid world-age issues.","category":"page"},{"location":"tutorials/symbolic_functions/#Building-Non-Allocating-Parallel-Functions-for-Sparse-Matrices-1","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Building Non-Allocating Parallel Functions for Sparse Matrices","text":"","category":"section"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Now let's show off a little bit. build_function is kind of like if lambdify ate its spinach. To show this, let's build a non-allocating function that fills sparse matrices in a multithreaded manner. To do this, we just have to represent the operation that we're turning into a function via a sparse matrix. For example:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"N = 8\nA = sparse(Tridiagonal([x^i for i in 1:N-1],[x^i * y^(8-i) for i in 1:N], [y^i for i in 1:N-1]))\n\n8×8 SparseMatrixCSC{Num,Int64} with 22 stored entries:\n  [1, 1]  =  x ^ 1 * y ^ 7\n  [2, 1]  =  x ^ 1\n  [1, 2]  =  y ^ 1\n  [2, 2]  =  x ^ 2 * y ^ 6\n  [3, 2]  =  x ^ 2\n  [2, 3]  =  y ^ 2\n  [3, 3]  =  x ^ 3 * y ^ 5\n  [4, 3]  =  x ^ 3\n  [3, 4]  =  y ^ 3\n  ⋮\n  [5, 5]  =  x ^ 5 * y ^ 3\n  [6, 5]  =  x ^ 5\n  [5, 6]  =  y ^ 5\n  [6, 6]  =  x ^ 6 * y ^ 2\n  [7, 6]  =  x ^ 6\n  [6, 7]  =  y ^ 6\n  [7, 7]  =  x ^ 7 * y ^ 1\n  [8, 7]  =  x ^ 7\n  [7, 8]  =  y ^ 7\n  [8, 8]  =  x ^ 8 * y ^ 0","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Now we call build_function:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"build_function(A,[x,y],parallel=Symbolics.MultithreadedForm())[2]","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"which generates the code:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"(var\"##MTIIPVar#317\", var\"##MTKArg#315\")->begin\n        @inbounds begin\n                @sync begin\n                        let (x, y) = (var\"##MTKArg#315\"[1], var\"##MTKArg#315\"[2])\n                            begin\n                                Threads.@spawn begin\n                                        (var\"##MTIIPVar#317\").nzval[1] = (getproperty(Base, :*))((getproperty(Base, :^))(x, 1), (getproperty(Base, :^))(y, 7))\n                                        (var\"##MTIIPVar#317\").nzval[2] = (getproperty(Base, :^))(x, 1)\n                                        (var\"##MTIIPVar#317\").nzval[3] = (getproperty(Base, :^))(y, 1)\n                                        (var\"##MTIIPVar#317\").nzval[4] = (getproperty(Base, :*))((getproperty(Base, :^))(x, 2), (getproperty(Base, :^))(y, 6))\n                                        (var\"##MTIIPVar#317\").nzval[5] = (getproperty(Base, :^))(x, 2)\n                                        (var\"##MTIIPVar#317\").nzval[6] = (getproperty(Base, :^))(y, 2)\n                                    end\n                            end\n                            begin\n                                Threads.@spawn begin\n                                        (var\"##MTIIPVar#317\").nzval[7] = (getproperty(Base, :*))((getproperty(Base, :^))(x, 3), (getproperty(Base, :^))(y, 5))\n                                        (var\"##MTIIPVar#317\").nzval[8] = (getproperty(Base, :^))(x, 3)\n                                        (var\"##MTIIPVar#317\").nzval[9] = (getproperty(Base, :^))(y, 3)\n                                        (var\"##MTIIPVar#317\").nzval[10] = (getproperty(Base, :*))((getproperty(Base, :^))(x, 4), (getproperty(Base, :^))(y, 4))\n                                        (var\"##MTIIPVar#317\").nzval[11] = (getproperty(Base, :^))(x, 4)\n                                        (var\"##MTIIPVar#317\").nzval[12] = (getproperty(Base, :^))(y, 4)\n                                    end\n                            end\n                            begin\n                                Threads.@spawn begin\n                                        (var\"##MTIIPVar#317\").nzval[13] = (getproperty(Base, :*))((getproperty(Base, :^))(x, 5), (getproperty(Base, :^))(y, 3))\n                                        (var\"##MTIIPVar#317\").nzval[14] = (getproperty(Base, :^))(x, 5)\n                                        (var\"##MTIIPVar#317\").nzval[15] = (getproperty(Base, :^))(y, 5)\n                                        (var\"##MTIIPVar#317\").nzval[16] = (getproperty(Base, :*))((getproperty(Base, :^))(x, 6), (getproperty(Base, :^))(y, 2))\n                                        (var\"##MTIIPVar#317\").nzval[17] = (getproperty(Base, :^))(x, 6)\n                                        (var\"##MTIIPVar#317\").nzval[18] = (getproperty(Base, :^))(y, 6)\n                                    end\n                            end\n                            begin\n                                Threads.@spawn begin\n                                        (var\"##MTIIPVar#317\").nzval[19] = (getproperty(Base, :*))((getproperty(Base, :^))(x, 7), (getproperty(Base, :^))(y, 1))\n                                        (var\"##MTIIPVar#317\").nzval[20] = (getproperty(Base, :^))(x, 7)\n                                        (var\"##MTIIPVar#317\").nzval[21] = (getproperty(Base, :^))(y, 7)\n                                        (var\"##MTIIPVar#317\").nzval[22] = (getproperty(Base, :*))((getproperty(Base, :^))(x, 8), (getproperty(Base, :^))(y, 0))\n                                    end\n                            end\n                        end\n                    end\n            end\n        nothing\n    end","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Let's unpack what that's doing. It's using A.nzval in order to linearly index through the sparse matrix, avoiding the A[i,j] form because that is a more expensive way to index a sparse matrix if you know exactly the order that the data is stored. Then, it's splitting up the calculation into Julia threads so they can be operated on in parallel. It synchronizes after spawning all of the tasks so the computation is ensured to be complete before moving on. And it does this with all in-place operations to the original matrix instead of generating arrays. This is the fanciest way you could fill a sparse matrix, and Symbolics makes this dead simple.","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"(Note: this example may be slower with multithreading due to the thread spawning overhead, but the full version was not included in the documentation for brevity. It will be the faster version if N is sufficiently large!)","category":"page"},{"location":"tutorials/symbolic_functions/#Derivatives-1","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Derivatives","text":"","category":"section"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"One common thing to compute in a symbolic system is derivatives. In Symbolics.jl, derivatives are represented lazily via operations, just like any other function. To build a differential operator, use Differential like:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"@variables t\nD = Differential(t)","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"This is the differential operator D = fracpartialpartial t: the number of ' is the order of the derivative and the second variable is the variable we're differentiating by. Now let's write down the derivative of some expression:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"z = t + t^2\nD(z) # derivative(t + t ^ 2, t)","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Notice that this hasn't computed anything yet: D is a lazy operator because it lets us symbolically represent \"The derivative of z with respect to t\", which is useful for example when representing our favorite thing in the world, differential equations. However, if we want to expand the derivative operators, we'd use expand_derivatives:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"expand_derivatives(D(z)) # 1 + 2t","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"We can also have simplified functions for multivariable calculus. For example, we can compute the Jacobian of an array of expressions like:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Symbolics.jacobian([x+x*y,x^2+y],[x,y])\n\n2×2 Array{Num,2}:\n 1 + y            x\n    2x  Constant(1)","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"and similarly we can do Hessians, gradients, and define whatever other derivatives you want.","category":"page"},{"location":"tutorials/symbolic_functions/#Simplification-and-Substitution-1","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Simplification and Substitution","text":"","category":"section"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Symbolics interfaces with SymbolicUtils.jl to allow for simplifying symbolic expressions. This is done simply through the simplify command:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"simplify(t+t) # 2t","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"This can be applied to arrays by using Julia's broadcast mechanism:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"B = simplify.([t^2+t+t^2  2t+4t\n           x+y+y+2t   x^2 - x^2 + y^2])\n\n2×2 Array{Num,2}:\n  2 * t ^ 2 + t     6t\nx + 2 * (t + y)  y ^ 2","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"We can then use substitute to change values of an expression around:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"simplify.(substitute.(B, (Dict(x=>y^2),)))\n\n2×2 Array{Num,2}:\n       2 * t ^ 2 + t     6t\n y ^ 2 + 2 * (t + y)  y ^ 2","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"and we can use this to interactively evaluate expressions without generating and compiling Julia functions:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"substitute.(B,((Dict(x=>2.0,y=>3.0,t=>4.0),)))\n\n2×2 Array{Symbolics.Constant,2}:\n Constant(36.0)  Constant(24.0)\n Constant(16.0)   Constant(9.0)","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Where we can reference the values via:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Symbolics.Constant(2.0).value # 2.0","category":"page"},{"location":"tutorials/symbolic_functions/#Non-Interactive-Development-(No-Macro-Version)-1","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Non-Interactive Development (No Macro Version)","text":"","category":"section"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Note that the macros are for the high-level case where you're doing symbolic computation on your own code. If you want to do symbolic computation on someone else's code, like in a macro, you may not want to do @variables x because you might want the name \"x\" to come from the user's code. For these cases, Symbolics.jl allows for fully macro-free usage. For example:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"x = Num(Sym{Float64}(:x))\ny = Num(Sym{Float64}(:y))\nx+y^2.0 # isa Num\n\nt = Num(Variable{Symbolics.Parameter{Real}}(:t))  # independent variables are treated as known\nα = Num(Variable{Symbolics.Parameter{Real}}(:α))  # parameters are known\nσ = Num(Variable{Symbolics.FnType{Tuple{Any},Real}}(:σ)) # left uncalled, since it is used as a function\nw = Num(Variable{Symbolics.FnType{Tuple{Any},Real}}(:w)) # unknown, left uncalled\nx = Num(Variable{Symbolics.FnType{Tuple{Any},Real}}(:x))(t)  # unknown, depends on `t`\ny = Num(Variable(:y))   # unknown, no dependents\nz = Num(Variable{Symbolics.FnType{NTuple{3,Any},Real}}(:z))(t, α, x)  # unknown, multiple arguments\nβ₁ = Num(Variable(:β, 1)) # with index 1\nβ₂ = Num(Variable(:β, 2)) # with index 2\n\nexpr = β₁ * x + y^α + σ(3) * (z - t) - β₂ * w(t - 1)","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Does what you'd expect. Note that Variable is simply a convenient function for making variables with indices that always returns Sym. The reference documentation shows how to define any of the quantities in such a way that the names can come from runtime values.","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"If we need to use this to generate new Julia code, we can simply convert the output to an Expr:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"toexpr(x+y^2)","category":"page"},{"location":"tutorials/symbolic_functions/#Syms-and-callable-Syms-1","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Syms and callable Syms","text":"","category":"section"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"In the definition","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"@variables t x(t) y(t)","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"t is of type Sym{Real} but the name x refers to an object that represents the Term x(t). The operation of this expression is itself the object Sym{FnType{Tuple{Real}, Real}}(:x). The type Sym{FnType{...}} represents a callable object. In this case specifically it's a function that takes 1 Real argument (noted by Tuple{Real}) and returns a Real result. You can call such a callable Sym with either a number or a symbolic expression of a permissible type.","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"this expression also defines t as a dependent variable while x(t) and y(t) are independent variables. This is accounted for in differentiation:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"z = x + y*t\nexpand_derivatives(D(z)) # derivative(x(t), t) + y(t) + derivative(y(t), t) * t","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Since x and y are time-dependent, they are not automatically eliminated from the expression and thus the D(x) and D(y) operations still exist in the expanded derivatives for correctness.","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"We can also define unrestricted functions:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"@variables g(..)","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Here g is a variable that is a function of other variables. Any time that we reference g we have to utilize it as a function:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"z = g(x) + g(y)","category":"page"},{"location":"tutorials/symbolic_functions/#Registering-Functions-1","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Registering Functions","text":"","category":"section"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"One of the benefits of a one-language Julia symbolic stack is that the primitives are all written in Julia, and therefore it's trivially extendible from Julia itself. By default, new functions are traced to the primitives and the symbolic expressions are written on the primitives. However, we can expand the allowed primitives by registering new functions. For example, let's register a new function h:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"h(x,y) = x^2 + y\n@register h(x,y)","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Now when we use h(x,y), it is a symbolic expression and doesn't expand:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"h(x,y) + y^2","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"In order to use it with the differentiation system, we need to register its derivatives. We would do it like this:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"# Derivative w.r.t. the first argument\nSymbolics.derivative(::typeof(h), args::NTuple{2,Any}, ::Val{1}) = 2args[1]\n# Derivative w.r.t. the second argument\nSymbolics.derivative(::typeof(h), args::NTuple{2,Any}, ::Val{2}) = 1","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"and now it works with the rest of the system:","category":"page"},{"location":"tutorials/symbolic_functions/#","page":"Symbolic Calculations and Building Fast Parallel Functions","title":"Symbolic Calculations and Building Fast Parallel Functions","text":"Dx = Differential(x)\nDy = Differential(y)\nexpand_derivatives(Dx(h(x,y) + y^2)) # 2x\nexpand_derivatives(Dy(h(x,y) + y^2)) # 1 + 2y","category":"page"},{"location":"manual/sparsity_detection/#Sparsity-Detection-1","page":"Sparsity Detection","title":"Sparsity Detection","text":"","category":"section"},{"location":"manual/sparsity_detection/#","page":"Sparsity Detection","title":"Sparsity Detection","text":"Using the tracing system provided by Symbolics.jl expressions, Symbolics.jl can automatically detect the sparsity patterns of Julia functions. This functionality is described in more detail in the paper:","category":"page"},{"location":"manual/sparsity_detection/#","page":"Sparsity Detection","title":"Sparsity Detection","text":"@article{gowda2019sparsity,\n  title={Sparsity Programming: Automated Sparsity-Aware Optimizations in Differentiable Programming},\n  author={Gowda, Shashi and Ma, Yingbo and Churavy, Valentin and Edelman, Alan and Rackauckas, Christopher},\n  year={2019}\n}","category":"page"},{"location":"manual/sparsity_detection/#","page":"Sparsity Detection","title":"Sparsity Detection","text":"Please cite this work if the functionality is used.","category":"page"},{"location":"manual/sparsity_detection/#","page":"Sparsity Detection","title":"Sparsity Detection","text":"Symbolics.jacobian_sparsity\nSymbolics.hessian_sparsity","category":"page"},{"location":"manual/sparsity_detection/#Symbolics.jacobian_sparsity","page":"Sparsity Detection","title":"Symbolics.jacobian_sparsity","text":"jacobian_sparsity(ops::AbstractVector, vars::AbstractVector)\n\nReturn the sparsity pattern of the Jacobian of an array of expressions with respect to an array of variable expressions.\n\n\n\n\n\n","category":"function"},{"location":"manual/sparsity_detection/#Symbolics.hessian_sparsity","page":"Sparsity Detection","title":"Symbolics.hessian_sparsity","text":"hessian_sparsity(ops::AbstractVector, vars::AbstractVector)\n\nReturn the sparsity pattern of the Hessian of an array of expressions with respect to an array of variable expressions.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/auto_parallel/#Automated-Sparse-Parallelism-of-ODEs-via-Tracing-1","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"","category":"section"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"Because the Symbolics.jl expressions obey Julia semantics, one can directly transform existing Julia functions into Symbolics.jl symbolic representations of the function by simply inputting the symbolic values into the function and using what is returned. For example, let's take the following numerical PDE discretization:","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"using Symbolics, LinearAlgebra, SparseArrays\n\n# Define the constants for the PDE\nconst α₂ = 1.0\nconst α₃ = 1.0\nconst β₁ = 1.0\nconst β₂ = 1.0\nconst β₃ = 1.0\nconst r₁ = 1.0\nconst r₂ = 1.0\nconst _DD = 100.0\nconst γ₁ = 0.1\nconst γ₂ = 0.1\nconst γ₃ = 0.1\nconst N = 32\nconst X = reshape([i for i in 1:N for j in 1:N],N,N)\nconst Y = reshape([j for i in 1:N for j in 1:N],N,N)\nconst α₁ = 1.0.*(X.>=4*N/5)\n\nconst Mx = Array(Tridiagonal([1.0 for i in 1:N-1],[-2.0 for i in 1:N],[1.0 for i in 1:N-1]))\nconst My = copy(Mx)\nMx[2,1] = 2.0\nMx[end-1,end] = 2.0\nMy[1,2] = 2.0\nMy[end,end-1] = 2.0\n\n# Define the discretized PDE as an ODE function\nfunction f(u,p,t)\n    A = u[:,:,1]\n    B = u[:,:,2]\n    C = u[:,:,3]\n    MyA = My*A\n    AMx = A*Mx\n    DA = @. _DD*(MyA + AMx)\n    dA = @. DA + α₁ - β₁*A - r₁*A*B + r₂*C\n    dB = @. α₂ - β₂*B - r₁*A*B + r₂*C\n    dC = @. α₃ - β₃*C + r₁*A*B - r₂*C\n    cat(dA,dB,dC,dims=3)\nend","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"We can build the Symbolics version of this model by tracing the model function:","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"# Define the initial condition as normal arrays\n@variables u[1:N,1:N,1:3]\ndu = simplify.(f(u,nothing,0.0))","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"The output, here the in-place modified du, is a symbolic representation of each output of the function. We can then utilize this in the Symbolics functionality. For example, let's build a parallel version of f first:","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"fastf = eval(Symbolics.build_function(du,u,\n            parallel=Symbolics.MultithreadedForm())[2])","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"Now let's compute the sparse Jacobian function and compile a fast multithreaded version:","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"jac = Symbolics.sparsejacobian(vec(du),vec(u))\nfjac = eval(Symbolics.build_function(jac,u,\n            parallel=Symbolics.MultithreadedForm())[2])","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"It takes awhile for this to generate, but the results will be worth it! Now let's setup the parabolic PDE to be solved by DifferentialEquations.jl. We will setup the vanilla version and the sparse multithreaded version:","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"using OrdinaryDiffEq\nu0 = zeros(N,N,3)\nMyA = zeros(N,N);\nAMx = zeros(N,N);\nDA = zeros(N,N);\nprob = ODEProblem(f!,u0,(0.0,10.0))\nfastprob = ODEProblem(ODEFunction((du,u,p,t)->fastf(du,u),\n                                   jac = (du,u,p,t) -> fjac(du,u),\n                                   jac_prototype = similar(jac,Float64)),\n                                   u0,(0.0,10.0))","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"Let's see the timing difference:","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"using BenchmarkTools\n@btime solve(prob, TRBDF2()) # 33.073 s (895404 allocations: 23.87 GiB)\n@btime solve(fastprob, TRBDF2()) # 209.670 ms (8208 allocations: 109.25 MiB)","category":"page"},{"location":"tutorials/auto_parallel/#","page":"Automated Sparse Parallelism of ODEs via Tracing","title":"Automated Sparse Parallelism of ODEs via Tracing","text":"Boom, an automatic 157x acceleration that grows as the size of the problem increases!","category":"page"},{"location":"manual/io/#I/O,-Saving,-and-Latex-1","page":"I/O, Saving, and Latex","title":"I/O, Saving, and Latex","text":"","category":"section"},{"location":"manual/io/#","page":"I/O, Saving, and Latex","title":"I/O, Saving, and Latex","text":"Note that Julia's standard I/O functionality can be used to save Symbolics expressions out to files. For example, here we will generate an in-place version of f and save the anonymous function to a .jl file:","category":"page"},{"location":"manual/io/#","page":"I/O, Saving, and Latex","title":"I/O, Saving, and Latex","text":"using Symbolics\n@variables u[1:3]\nfunction f(u)\n  [u[1]-u[3],u[1]^2-u[2],u[3]+u[2]]\nend\nex1, ex2 = build_function(f(u),u)\nwrite(\"function.jl\", string(ex2))","category":"page"},{"location":"manual/io/#","page":"I/O, Saving, and Latex","title":"I/O, Saving, and Latex","text":"Now we can do something like:","category":"page"},{"location":"manual/io/#","page":"I/O, Saving, and Latex","title":"I/O, Saving, and Latex","text":"f = include(\"function.jl\")","category":"page"},{"location":"manual/io/#","page":"I/O, Saving, and Latex","title":"I/O, Saving, and Latex","text":"and that will load the function back in. Note that this can be done to save the transformation results of Symbolics.jl so that they can be stored and used in a precompiled Julia package.","category":"page"},{"location":"manual/io/#Latexification-1","page":"I/O, Saving, and Latex","title":"Latexification","text":"","category":"section"},{"location":"manual/io/#","page":"I/O, Saving, and Latex","title":"I/O, Saving, and Latex","text":"Symbolics.jl's expressions support Latexify.jl, and thus","category":"page"},{"location":"manual/io/#","page":"I/O, Saving, and Latex","title":"I/O, Saving, and Latex","text":"using Latexify\nlatexify(ex)","category":"page"},{"location":"manual/io/#","page":"I/O, Saving, and Latex","title":"I/O, Saving, and Latex","text":"will produce LaTeX output from Symbolics models and expressions. This works on basics like Term all the way to higher primitives like ODESystem and ReactionSystem.","category":"page"},{"location":"tutorials/converting_to_C/#Automatic-Conversion-of-Julia-Code-to-C-Functions-1","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"","category":"section"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"Since Symbolics.jl can trace Julia code into MTK IR that can be built and compiled via build_function to C, this gives us a nifty way to automatically generate C functions from Julia code! To see this in action, let's start with the Lotka-Volterra equations:","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"using Symbolics\nfunction lotka_volterra!(du, u, p, t)\n  x, y = u\n  α, β, δ, γ = p\n  du[1] = dx = α*x - β*x*y\n  du[2] = dy = -δ*y + γ*x*y\nend","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"Now we trace this into Symbolics:","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"@variables t du[1:2] u[1:2] p[1:4]\nlotka_volterra!(du, u, p, t)","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"which gives:","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"du = Num[p₁ * u₁ - (p₂ * u₁) * u₂, -p₃ * u₂ + (p₄ * u₁) * u₂]","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"Now we build the equations we want to solve:","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"eqs = @. D(u) ~ du\n\n2-element Array{Equation,1}:\n Equation(derivative(u₁, t), p₁ * u₁ - (p₂ * u₁) * u₂)\n Equation(derivative(u₂, t), -p₃ * u₂ + (p₄ * u₁) * u₂)","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"and then we build the function:","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"build_function(eqs, u, p, t, target=Symbolics.CTarget())\n\nvoid diffeqf(double* du, double* RHS1, double* RHS2, double RHS3) {\n  du[0] = RHS2[0] * RHS1[0] - (RHS2[1] * RHS1[0]) * RHS1[1];\n  du[1] = -(RHS2[2]) * RHS1[1] + (RHS2[3] * RHS1[0]) * RHS1[1];\n}","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"If we want to compile this, we do expression=Val{false}:","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"f = build_function(eqs, u, p, t, target=Symbolics.CTarget(),expression=Val{false})","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"now we check it computes the same thing:","category":"page"},{"location":"tutorials/converting_to_C/#","page":"Automatic Conversion of Julia Code to C Functions","title":"Automatic Conversion of Julia Code to C Functions","text":"du = rand(2); du2 = rand(2)\nu = rand(2)\np = rand(4)\nt = rand()\nf(du,u,p,t)\nlotka_volterra!(du2, u, p, t)\ndu == du2 # true!","category":"page"},{"location":"manual/build_function/#Function-Building-and-Compilation-(build_function)-1","page":"Function Building and Compilation (build_function)","title":"Function Building and Compilation (build_function)","text":"","category":"section"},{"location":"manual/build_function/#","page":"Function Building and Compilation (build_function)","title":"Function Building and Compilation (build_function)","text":"At any time, callable functions can be generated from Symbolics IR by using Symbolics.toexpr. This performs some cleaning to return an expression without extraneous pieces that commonly matches expressions one would write in functions like those for differential equation solvers and optimization libraries. These functions can be automatically parallelize and specialize on Julia types like static arrays and sparse matrices.","category":"page"},{"location":"manual/build_function/#","page":"Function Building and Compilation (build_function)","title":"Function Building and Compilation (build_function)","text":"The core compilation process of Symbolics IR is build_function. build_function takes an operation or an AbstractArray of operations and generates a compilable version of the model for numerical solvers. The form of this output is dependent on the target. By default, the target outputs Julia code, but other formats, such as C, Stan, and MATLAB are available. These can be generated as expressions which can then be evaluated into a callable function, or the compilers for the respective targets can be invoked to directly give back the function handle.","category":"page"},{"location":"manual/build_function/#build_function-1","page":"Function Building and Compilation (build_function)","title":"build_function","text":"","category":"section"},{"location":"manual/build_function/#","page":"Function Building and Compilation (build_function)","title":"Function Building and Compilation (build_function)","text":"build_function","category":"page"},{"location":"manual/build_function/#Target-Specific-Definitions-1","page":"Function Building and Compilation (build_function)","title":"Target-Specific Definitions","text":"","category":"section"},{"location":"manual/build_function/#","page":"Function Building and Compilation (build_function)","title":"Function Building and Compilation (build_function)","text":"_build_function(target::JuliaTarget,args...;kwargs...)\n_build_function(target::CTarget,args...;kwargs...)\n_build_function(target::StanTarget,args...;kwargs...)\n_build_function(target::MATLABTarget,args...;kwargs...)","category":"page"},{"location":"manual/functions/#Function-Registration-and-Tracing-1","page":"Function Registration and Tracing","title":"Function Registration and Tracing","text":"","category":"section"},{"location":"manual/functions/#Direct-Tracing-1","page":"Function Registration and Tracing","title":"Direct Tracing","text":"","category":"section"},{"location":"manual/functions/#","page":"Function Registration and Tracing","title":"Function Registration and Tracing","text":"Because Symbolics expressions respect Julia semantics, one way to generate symbolic expressions is to simply place Symbolics variables as inputs into existing Julia code. For example, the following uses the standard Julia function for the Lorenz equations to generate the symbolic expression for the Lorenz equations:","category":"page"},{"location":"manual/functions/#","page":"Function Registration and Tracing","title":"Function Registration and Tracing","text":"function lorenz(du,u,p,t)\n du[1] = 10.0(u[2]-u[1])\n du[2] = u[1]*(28.0-u[3]) - u[2]\n du[3] = u[1]*u[2] - (8/3)*u[3]\nend\n@variables t u[1:3](t) du[1:3](t)\n@parameters p[1:3]\nlorenz(du,u,p,t)\ndu","category":"page"},{"location":"manual/functions/#","page":"Function Registration and Tracing","title":"Function Registration and Tracing","text":"3-element Array{Num,1}:\n                 10.0 * (u₂(t) - u₁(t))\n         u₁(t) * (28.0 - u₃(t)) - u₂(t)\nu₁(t) * u₂(t) - 2.6666666666666665 * u₃(t)","category":"page"},{"location":"manual/functions/#","page":"Function Registration and Tracing","title":"Function Registration and Tracing","text":"Or similarly:","category":"page"},{"location":"manual/functions/#","page":"Function Registration and Tracing","title":"Function Registration and Tracing","text":"@variables t x(t) y(t) z(t) dx(t) dy(t) dz(t)\n@parameters σ ρ β\ndu = [dx,dy,dz]\nu = [x,y,z]\np = [σ,ρ,β]\nlorenz(du,u,p,t)\ndu","category":"page"},{"location":"manual/functions/#","page":"Function Registration and Tracing","title":"Function Registration and Tracing","text":"3-element Array{Num,1}:\n                10.0 * (y(t) - x(t))\n         x(t) * (28.0 - z(t)) - y(t)\nx(t) * y(t) - 2.6666666666666665 * z(t)","category":"page"},{"location":"manual/functions/#Registering-Functions-1","page":"Function Registration and Tracing","title":"Registering Functions","text":"","category":"section"},{"location":"manual/functions/#","page":"Function Registration and Tracing","title":"Function Registration and Tracing","text":"The Symbolics graph only allows registered Julia functions within its type. All other functions are automatically traced down to registered functions. By default, Symbolics.jl pre-registers the common functions utilized in SymbolicUtils.jl and pre-defines their derivatives. However, the user can utilize the @register macro to add their function to allowed functions of the computation graph.","category":"page"},{"location":"manual/functions/#","page":"Function Registration and Tracing","title":"Function Registration and Tracing","text":"@register","category":"page"},{"location":"manual/functions/#Symbolics.@register","page":"Function Registration and Tracing","title":"Symbolics.@register","text":"@register(expr, define_promotion, Ts = [Num, Symbolic, Real])\n\nOverload approperate methods such that ModelingToolkit can stop tracing into the registered function.\n\nExamples\n\n@register foo(x, y)\n@register goo(x, y::Int) # `y` is not overloaded to take symbolic objects\n@register hoo(x, y)::Int # `hoo` returns `Int`\n\n\n\n\n\n","category":"macro"},{"location":"manual/expression_manipulation/#Expression-Manipulation-1","page":"Expression Manipulation","title":"Expression Manipulation","text":"","category":"section"},{"location":"manual/expression_manipulation/#","page":"Expression Manipulation","title":"Expression Manipulation","text":"Symbolics.jl provides functionality for easily manipulating expressions. Most of the functionality comes by the expression objects obeying the standard mathematical semantics. For example, if one has A a matrix of symbolic expressions wrapped in Num, then A^2 calculates the expressions for the squared matrix.  In that sense, it is encouraged that one uses standard Julia for performing a lot of the manipulation on the IR, as, for example, calculating the sparse form of the matrix via sparse(A) is valid, legible, and easily understandable to all Julia programmers.","category":"page"},{"location":"manual/expression_manipulation/#","page":"Expression Manipulation","title":"Expression Manipulation","text":"Other additional manipulation functions are given below.","category":"page"},{"location":"manual/expression_manipulation/#","page":"Expression Manipulation","title":"Expression Manipulation","text":"get_variables\nsubstitute\ntovar\ntoparam\ntosymbol\nmakesym\ndiff2term\nsolve_for","category":"page"},{"location":"manual/derivatives/#Derivatives-and-Differentials-1","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"","category":"section"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"A Differential(op) is a partial derivative with respect to op, which can then be applied to some other operations. For example, D=Differential(t) is what would commonly be referred to as d/dt, which can then be applied to other operations using its function call, so D(x+y) is d(x+y)/dt.","category":"page"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"By default, the derivatives are left unexpanded to capture the symbolic representation of the differential equation. If the user would like to expand out all of the differentials, the expand_derivatives function eliminates all of the differentials down to basic one-variable expressions.","category":"page"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"Differential\nSymbolics.derivative\nexpand_derivatives\nSymbolics.jacobian\nSymbolics.sparsejacobian\nSymbolics.gradient\nSymbolics.hessian\nSymbolics.sparsehessian","category":"page"},{"location":"manual/derivatives/#Symbolics.Differential","page":"Derivatives and Differentials","title":"Symbolics.Differential","text":"struct Differential <: Function\n\nRepresents a differential operator.\n\nFields\n\nx\nThe variable or expression to differentiate with respect to.\n\nExamples\n\njulia> using ModelingToolkit\n\njulia> @variables x y;\n\njulia> D = Differential(x)\n(D'~x)\n\njulia> D(y) # Differentiate y wrt. x\n(D'~x)(y)\n\njulia> Dx = Differential(x) * Differential(y) # d^2/dxy operator\n(D'~x(t)) ∘ (D'~y(t))\n\njulia> D3 = Differential(x)^3 # 3rd order differential operator\n(D'~x(t)) ∘ (D'~x(t)) ∘ (D'~x(t))\n\n\n\n\n\n","category":"type"},{"location":"manual/derivatives/#Symbolics.derivative","page":"Derivatives and Differentials","title":"Symbolics.derivative","text":"derivative(O, v; simplify)\n\n\nA helper function for computing the derivative of an expression with respect to var.\n\n\n\n\n\n","category":"function"},{"location":"manual/derivatives/#Symbolics.expand_derivatives","page":"Derivatives and Differentials","title":"Symbolics.expand_derivatives","text":"expand_derivatives(O)\nexpand_derivatives(O, simplify; occurances)\n\n\nTODO\n\n\n\n\n\n","category":"function"},{"location":"manual/derivatives/#Symbolics.jacobian","page":"Derivatives and Differentials","title":"Symbolics.jacobian","text":"jacobian(ops, vars; simplify)\n\n\nA helper function for computing the Jacobian of an array of expressions with respect to an array of variable expressions.\n\n\n\n\n\n","category":"function"},{"location":"manual/derivatives/#Symbolics.sparsejacobian","page":"Derivatives and Differentials","title":"Symbolics.sparsejacobian","text":"sparsejacobian(ops, vars; simplify)\n\n\nA helper function for computing the sparse Jacobian of an array of expressions with respect to an array of variable expressions.\n\n\n\n\n\n","category":"function"},{"location":"manual/derivatives/#Symbolics.gradient","page":"Derivatives and Differentials","title":"Symbolics.gradient","text":"gradient(O, vars; simplify)\n\n\nA helper function for computing the gradient of an expression with respect to an array of variable expressions.\n\n\n\n\n\n","category":"function"},{"location":"manual/derivatives/#Symbolics.hessian","page":"Derivatives and Differentials","title":"Symbolics.hessian","text":"hessian(O, vars; simplify)\n\n\nA helper function for computing the Hessian of an expression with respect to an array of variable expressions.\n\n\n\n\n\n","category":"function"},{"location":"manual/derivatives/#Symbolics.sparsehessian","page":"Derivatives and Differentials","title":"Symbolics.sparsehessian","text":"sparsehessian(O, vars; simplify)\n\n\nA helper function for computing the sparse Hessian of an expression with respect to an array of variable expressions.\n\n\n\n\n\n","category":"function"},{"location":"manual/derivatives/#Adding-Analytical-Derivatives-1","page":"Derivatives and Differentials","title":"Adding Analytical Derivatives","text":"","category":"section"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"There is a large amount of derivatives pre-defined by DiffRules.jl.","category":"page"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"f(x,y,z) = x^2 + sin(x+y) - z","category":"page"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"automatically has the derivatives defined via the tracing mechanism. It will do this by directly building the operation the internals of your function and differentiating that.","category":"page"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"However, in many cases you may want to define your own derivatives so that way automatic Jacobian etc. calculations can utilize this information. This can allow for more succinct versions of the derivatives to be calculated in order to better scale to larger systems. You can define derivatives for your own function via the dispatch:","category":"page"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"# `N` arguments are accepted by the relevant method of `my_function`\nSymbolics.derivative(::typeof(my_function), args::NTuple{N,Any}, ::Val{i})","category":"page"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"where i means that it's the derivative with respect to the ith argument. args is the array of arguments, so, for example, if your function is f(x,t), then args = [x,t]. You should return an Term for the derivative of your function.","category":"page"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"For example, sin(t)'s derivative (by t) is given by the following:","category":"page"},{"location":"manual/derivatives/#","page":"Derivatives and Differentials","title":"Derivatives and Differentials","text":"Symbolics.derivative(::typeof(sin), args::NTuple{1,Any}, ::Val{1}) = cos(args[1])","category":"page"},{"location":"#Symbolics.jl-1","page":"Home","title":"Symbolics.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Symbolics.jl is a fast and modern Computer Algebra System (CAS) for a fast and modern programming language (Julia). The goal is to have a high-performance and parallelized symbolic algebra system that is directly extendable in the same language as the users.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To install Symbolics.jl, use the Julia package manager:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Symbolics\")","category":"page"},{"location":"#Feature-Summary-1","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Because Symbolics.jl is built into the Julia language and works with its dispatches, generic functions in Base Julia will work with symbolic expressions! Make matrices of symbolic expressions and multiply them: it will just work. Take the LU-factorization. Etc. Thus see the Julia Documentation for a large list of functionality available in Symbolics.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In addition, Symbolics.jl adds specific functions for:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Simplification and substitution\nDifferentiation\nAutomatic conversion of Julia code to symbolic code\nGeneration of (high performance and parallel) functions from symbolic expressions\nAutomated sparsity detection of Julia code","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and much more.","category":"page"},{"location":"#Extension-Packages-1","page":"Home","title":"Extension Packages","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ModelingToolkit.jl: Symbolic representations of models, like ODEs, SDEs, PDEs, optimization, optimal control, nonlinear solves, and more.","category":"page"}]
}
